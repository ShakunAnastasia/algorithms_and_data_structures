def g(n):
    sum = 0
    for i in range(1, n + 1):
        sum = sum + i + f(i)
    return sum

1. Асимптотична оцінка (O-велике):
Зовнішній цикл for йде від 1 до n
На кожній ітерації викликається f(i)
З 2.10 маємо, що складність f(i) становить O(i)
Загальний час виконання це сума: 
T(n) = f(1) + f(2) + f(3) + ... + f(n)
T(n) = 1 + 2 + 3 + ... + n = n*(n+1)/2
n*(n+1)/2 - це функція порядку n^2
Складність у найгіршому випадку - O(n^2)

2. Результат виконання:
f(i) повертає суму чисел від 1 до i
g(n) рахує суму: (1 + f(1)) + (2 + f(2)) + ... + (n + f(n))
Якщо підставити f(i) = i*(i+1)/2, то g(n) - це сума арифметичної прогресії та сума її часткових сум
Це сума вигляду Σ(i + i*(i+1)/2)

3. Оптимізація:
Ми можемо це покращити таким чином : замінити виклик f(i) на формулу i*(i+1)//2, тоді складність впаде з O(n^2) до O(n), бо цикл стане простим, далі виведемо одну велику формулу для всієї суми g(n) (через суму квадратів і лінійну суму)
Тоді складність стане O(1)
   def g(n):
       res = 0
       for i in range(1, n + 1):
           res += i + (i * (i + 1) // 2)
       return res
