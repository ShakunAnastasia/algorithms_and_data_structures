----------------- a, b, c -----------------
Дано :
a) Σ i (від 0 до n) = O(n)
b) Σ i^2 (від 0 до n) = O(n)
c) Σ a^i (від 0 до n) = O(n)

Доведення: для цих сум достатньо одного циклу, навіть якщо ми додаємо квадрати чи степені, ми робимо це за один прохід.

s = 0
for i in range(n + 1):
    для (a): s += i
    для (b): s += i * i
    для (c): s += a ** i (якщо a - константа)
    pass 

Оцінка: цикл виконується n разів, кожна операція всередині — O(1), разом: O(n), доведено.

----------------- d -----------------
Дано: Σ i^i (від 0 до n) = O(n^2)

Доведення: обчислення i^i само по собі займає час. Якщо ми не використовуємо вбудовану функцію, а рахуємо через цикл:

total_sum = 0
for i in range(1, n + 1):      # зовнішній цикл: n разів
    term = 1
    for j in range(i):         # внутрішній цикл: i разів (рахуємо i^i)
        term *= i
    total_sum += term

Оцінка: Σ i (від 1 до n) = n*(n+1)/2 = O(n^2), доведено.

----------------- e, f, g -----------------
Дано:
e) П (1 / (1 + i)) = O(n)
f) П (1 / (1 + i!)) = O(n)
g) П (a^i / (1 + i!)) = O(n)

Доведення : щоб вкластися в O(n) для факторіалів, нам треба накопичувати факторіал у змінній, а не рахувати його щоразу заново.

p = 1
fact = 1
for i in range(1, n + 1):
    fact *= i                  # отримуємо i! з попереднього (i-1)! за O(1)
    p *= 1 / (1 + fact)        # обчислюємо поточний крок добутку

Оцінка: 1 цикл на n ітерацій, всередині лише O(1), разом: O(n), доведено.

----------------- h, i -----------------
Дано:
h) П (1 / (1 + i^m)) = O(n)
i) П (1 / (1 + i^i)) = O(n^2)

Доведення :
h) аналогічно до (e), якщо m - константа, i^m рахується швидко, цикл на n ітерацій дає O(n).
   
i) а ось для i^i нам знову потрібен вкладений цикл (як у d), щоб отримати степінь через множення:

p = 1
for i in range(1, n + 1):
    term = 1
    for j in range(i):         # рахуємо i^i за i кроків
        term *= i
    p *= 1 / (1 + term)

Оцінка: сума ітерацій 1+2+3...+n = O(n^2), доведено.
